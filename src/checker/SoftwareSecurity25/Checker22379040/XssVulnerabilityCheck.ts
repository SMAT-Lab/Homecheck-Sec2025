import {ArkFile, ArkStaticInvokeExpr, AstTreeUtils, Constant, DefUseChain, Stmt, ts} from 'arkanalyzer';
import Logger, {LOG_MODULE_TYPE} from 'arkanalyzer/lib/utils/logger';
import {BaseChecker, BaseMetaData} from '../../BaseChecker';
import {Defects} from '../../../Index';
import {FileMatcher, MatcherCallback, MatcherTypes} from '../../../Index';
import {Rule} from '../../../Index';
import {IssueReport} from '../../../model/Defects';

const logger = Logger.getLogger(LOG_MODULE_TYPE.HOMECHECK, 'XssVulnerabilityCheck');

const gMetaData: BaseMetaData = {
    severity: 2,
    ruleDocPath: '',
    description: 'Detects potential Cross-Site Scripting (XSS) vulnerabilities in web content handling.'
};

export class XssVulnerabilityCheck implements BaseChecker {
    readonly metaData: BaseMetaData = gMetaData;
    public rule: Rule;
    public defects: Defects[] = [];
    public issues: IssueReport[] = [];

    private fileMatcher: FileMatcher = {
        matcherType: MatcherTypes.FILE
    };

    // WebView相关的危险方法
    private webMethods = [
        'loadData', 'loadUrl', 'runJavaScript', 'evaluateJavaScript'
    ];

    // HTML标签和属性
    private htmlPatterns = [
        '<div', '<span', '<p>', '<input', '<script', '<iframe',
        'innerHTML', 'outerHTML'
    ];

    public registerMatchers(): MatcherCallback[] {
        const fileMatchBuildCb: MatcherCallback = {
            matcher: this.fileMatcher,
            callback: this.check
        }
        return [fileMatchBuildCb];
    }

    public check = (targetFile: ArkFile) => {
        const sourceFile = AstTreeUtils.getSourceFileFromArkFile(targetFile);
        const sourceFileObject = ts.getParseTreeNode(sourceFile);
        for (const arkClass of targetFile.getClasses()) {
            for (const arkMethod of arkClass.getMethods()) {
                if (arkMethod.getName() == '_DEFAULT_ARK_METHOD') {
                    continue;
                }
                const methodName = arkMethod.getName();
                const cfg = arkMethod.getCfg();
                if (cfg == undefined) {
                    continue;
                }
                for (const stmt of cfg.getStmts()) {
                    this.checkXssVulnerability(targetFile, stmt);
                }
            }
        }
    }

    private checkXssVulnerability(targetFile: ArkFile, stmt: Stmt): void {
        const text = stmt.getOriginalText();
        if (!text) return;

        // 检查1: WebView方法调用
        if (stmt.getExprs().length > 0) {
            const expr = stmt.getExprs()[0];
            if (expr instanceof ArkStaticInvokeExpr) {
                const methodName = expr.getMethodSignature().getMethodSubSignature().getMethodName();
                if (this.webMethods.includes(methodName)) {
                    // 检查是否存在不安全的内容注入
                    if (this.containsUnsafeContentInjection(text)) {
                        this.reportIssue(targetFile, stmt, `unsafe-${methodName}`);
                    }
                }
            }
        }

        // 检查2: HTML字符串拼接
        if (this.containsHtmlConcatenation(text)) {
            this.reportIssue(targetFile, stmt, "html-concatenation");
        }

        // 检查3: 模板字符串中的HTML注入
        if (this.containsUnsafeHtmlTemplate(text)) {
            this.reportIssue(targetFile, stmt, "unsafe-html-template");
        }

        // 检查4: JavaScript代码动态执行
        if (this.containsUnsafeScriptExecution(text)) {
            this.reportIssue(targetFile, stmt, "unsafe-script-execution");
        }
    }

    private containsUnsafeContentInjection(text: string): boolean {
        // 检查是否包含HTML标签和字符串拼接
        return this.htmlPatterns.some(pattern => text.includes(pattern)) &&
               (text.includes(' + ') || text.includes('+=') || text.includes('.concat('));
    }

    private containsHtmlConcatenation(text: string): boolean {
        // 检查HTML字符串拼接模式
        const htmlConcatPatterns = [
            /"<[^>]+>" \+ /,           // "<tag>" + variable
            / \+ "<[^>]+>"/,           // variable + "<tag>"
            /htmlContent \+/,          // htmlContent + 
            /htmlOutput \+/,           // htmlOutput +
            /"<.*?" \+ .* \+ ".*>"/    // "<start>" + content + "</end>"
        ];
        return htmlConcatPatterns.some(pattern => pattern.test(text));
    }

    private containsUnsafeHtmlTemplate(text: string): boolean {
        // 检查模板字符串中的不安全HTML构建
        if (text.includes('`') && text.includes('${')) {
            return this.htmlPatterns.some(pattern => text.includes(pattern)) ||
                   text.includes('<html>') || text.includes('<body>') ||
                   text.includes('<head>') || text.includes('<title>');
        }
        return false;
    }

    private containsUnsafeScriptExecution(text: string): boolean {
        // 检查动态JavaScript执行模式
        const scriptPatterns = [
            /runJavaScript.*\+/,       // runJavaScript with concatenation
            /evaluateJavaScript.*\+/,  // evaluateJavaScript with concatenation
            /"var .* = " \+ /,         // "var xxx = " + userInput
            /scriptToExecute.*\+/      // scriptToExecute + 
        ];
        return scriptPatterns.some(pattern => pattern.test(text));
    }

    public reportIssue(arkFile: ArkFile, stmt: Stmt, issueType: string): void {
        const severity = this.rule.alert ?? this.metaData.severity;
        const filePath = arkFile.getFilePath();
        const originPositionInfo = stmt.getOriginPositionInfo();
        const lineNum = originPositionInfo.getLineNo();
        const text = stmt.getOriginalText();
        if (!text || text.length === 0) {
            return;
        }
        const startColumn = originPositionInfo.getColNo();
        const endColumn = startColumn + text.length;
        let defects = new Defects(lineNum, startColumn, endColumn, this.metaData.description, severity, this.rule.ruleId,
            filePath, this.metaData.ruleDocPath, true, false, false);
        this.issues.push(new IssueReport(defects, undefined));
    }
}
